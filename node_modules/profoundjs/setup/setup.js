
const htdocs_download_url = 'http://resources.profoundjs.com/profoundui_htdocs.zip';
const pjsBaseInstance = '/profoundjs-base/instances/';

const child_process = require('child_process');
const fs = require('fs');
const fse = require('fs-extra');
const path = require('path');
const extract = require('extract-zip');
const crypto = require('crypto');
const os = require('os');

var IBMi = (os.type() === 'OS400');
var setupDir = __dirname;
var dirSep = path.sep;
var dirParts = __dirname.split(dirSep);
while (dirParts.length > 0 && dirParts.pop() !== "node_modules") {};
if (dirParts.length === 0) {
  console.log("Can't find deployment directory.");
  process.exit(1);
}
var deployDir = dirParts.join(dirSep);
var silent = process.argv.includes("--silent");
if (process.env.SILENT_INSTALL) silent = true;

var portNumber = "8081";  // default port
if (process.env.PORT) portNumber = process.env.PORT;

function downloadHtdocs(htdocsDir, callback) {
  var zipFile = setupDir + dirSep + 'htdocs.zip';
  console.log("");
  console.log("Starting Download...")
  console.log("");

  const profound = require('profoundjs');

  profound.utils.downloadProgress(htdocs_download_url, zipFile, (err) => {

    if (err) {
      console.error("Download ended in error:");
      console.error(err);
      if (typeof callback === "function") callback();
    }
    else {
      console.log("");
      console.log("Download completed. Extracting...")
      extract(zipFile, { dir: htdocsDir })
      .then(
        function() {
          try {
            fs.unlinkSync(zipFile);  // delete zip file after it's unzipped
          }
          catch (error) {}
          console.log("Directory " + htdocsDir + " restored.");
        },
        function (err) {
          console.error("Extraction ended in error:");
          console.error(err);
        }
      )
      .finally(function() {
        if (typeof callback === "function") process.nextTick(callback);
      });
    }
  });
}

function ask(questionParm, defaultAnswer, validationFunction, callback) {
  var question = questionParm;
  if (defaultAnswer == null) defaultAnswer = "";
  if (typeof defaultAnswer !== "string") defaultAnswer = String(defaultAnswer);
  
  if (silent) {
    callback(defaultAnswer);
    return;
  }
  
  if (defaultAnswer !== "") {
    var lastChar = question.substr(question.length - 1, 1);
    if (lastChar === ":" || lastChar === "?") {    
      question = question.substr(0, question.length - 1) + " (" + defaultAnswer + ")" + lastChar;
    }
    else {
      question = question + " (" + defaultAnswer + ")" + ":";
    }
  }
  question += " ";

  
  var readlineInterface = require('readline').createInterface({
    input: process.stdin,
    output: process.stdout,
    terminal: false
  });

  readlineInterface.question(question, function(answer) {
    readlineInterface.close();
    if (answer == "") answer = defaultAnswer;
    answer = answer.trim();
    if (typeof validationFunction === "function" && validationFunction(answer) === false) {
      ask(questionParm, defaultAnswer, validationFunction, callback);
    }
    else {
      callback(answer);
    }
  });  
}

function fileExists(file) {
  var exists = false;
  try {
    var stat = fs.statSync(file);
    if (stat && stat.isFile()) exists = true;
  }
  catch (err) {
    exists = false;
  }
  return exists;
}

function directoryExists(dir) {
  var exists = false;
  try {
    var stat = fs.statSync(dir);
    if (stat && stat.isDirectory()) exists = true;
  }
  catch (err) {
    exists = false;
  }
  return exists;
}

function copyFile(file, destination, type, process) {
  if (type == null) type = "binary";
  var fileParts = file.split(dirSep);
  var fileName = fileParts[fileParts.length - 1];
  if (directoryExists(destination))
    var toFile = destination + dirSep + fileName;
  else
    var toFile = destination;
  var content = fs.readFileSync(file, type);
  if (typeof process === "function") content = process(content);
  fs.writeFileSync(toFile, content, type);
}

function copyDir(dir, destinationDir) {
  var dirParts = dir.split(dirSep);
  var dirName = dirParts[dirParts.length - 1];
  fs.mkdirSync(destinationDir + dirSep + dirName);
  files = fs.readdirSync(dir);
  files.forEach(function(file, index) {
    if(fs.lstatSync(dir + dirSep + file).isDirectory()) { // recurse
      copyDir(dir + dirSep + file, destinationDir + dirSep + dirName);
    } 
    else {
      copyFile(dir + dirSep + file, destinationDir + dirSep + dirName, null, null);
    }
  });
}


function createPackageFile() {
  if (IBMi)
    runCommand("CHGAUT OBJ('" + deployDir + "') USER(PROFOUNDJS) DTAAUT(*RWX) OBJAUT(*ALL)");

  if (fileExists(deployDir + dirSep + "package.json")) {
    console.log("package.json file exists.");
  } 
  else {    
    copyFile(setupDir + dirSep + "package.json", deployDir, "utf8");
    console.log("package.json created automatically with defaults.");
  }
}

function createStart(callback) {
  if (fileExists(deployDir + dirSep + "start.js")) {
      console.log("start.js file exists.");
      const profound = require("profoundjs");
      if (profound.PROMISES_MODE) {
        const convertStartJS = require("./convertStartJS.js");
        const changed = convertStartJS(deployDir + dirSep + "start.js");
        if (changed) {
          console.log("start.js file converted to Promises.");
        }
      }
    callback();
  } 
  else {
    copyFile(setupDir + dirSep + "start.js", deployDir, "utf8");
    console.log("start.js created.");
    callback();
  }
}

function createCall(callback) {
  if (fileExists(deployDir + dirSep + "call.js")) {
      console.log("call.js file exists.");
    callback();
  } 
  else {
    copyFile(setupDir + dirSep + "call.js", deployDir, "utf8");
    console.log("call.js created.");
    callback();
  }
}

function createUpdatepui(callback) {
  if (IBMi) {
    // This file is not needed on IBM i because the proper way to install Profound UI on IBM i is to download the full version from the web site
    callback();
    return;
  }
  if (fileExists(deployDir + dirSep + "updatepui.js")) {
      console.log("updatepui.js file exists.");
    callback();
  } 
  else {
    copyFile(setupDir + dirSep + "updatepui.js", deployDir, "utf8");
    console.log("updatepui.js created.");
    callback();
  }
}

function createStoreCredentials(callback) {

  if (fileExists(deployDir + dirSep + "store_credentials.js")) {
    console.log("store_credentials.js file exists.");
    callback();
  } 
  else {
    copyFile(setupDir + dirSep + "store_credentials.js", deployDir, "utf8");
    console.log("store_credentials.js created.");
    callback();
  }  
  
}

function createModulesDirectory() {
  if (directoryExists(deployDir + dirSep + "modules")) {
    console.log("modules directory exists.");
  }
  else {
    console.log("Creating modules directory.");
    fs.mkdirSync(deployDir + dirSep + "modules");
  }

  // Make sure on IBMi that user PROFOUNDJS has full access everything within the Modules directory
  if (IBMi)
    runCommand("CHGAUT OBJ('" + deployDir  + dirSep + "modules') USER(PROFOUNDJS) DTAAUT(*RWX) OBJAUT(*ALL) SUBTREE(*ALL)");
}

function createPuiscreens() {
  function copyFileOldVersionIs(version, compareStr){
    compareStr = compareStr || "=";
    console.log("Found Standard puiscreens.json file version "+compareStr+" "+version+", replacing with current version...");
    copyFile(setupDir + dirSep + "modules" + dirSep + "puiscreens.json", targetPuiScreensFile, "utf8");
    console.log("puiscreens.json file was replaced.");
  }

  // Check which version of puiscreens.json is installed.
  // Version 4.7.0 ships with a new version of puiscreens where the bound fields (SSUSER, SSPASSWORD, SSSUBMIT, SSERROR, etc) are now lower case,
  // so this would be a breaking change. So our install logic is now as follows: -
  // 1. Check the SHA key of existing puiscreens.json.
  // 2. If it's an official PJS screen, no customizations have been made, so it's safe to replace with this version.
  // 3. If it's not an official version, check if we have lower case User & Password. If not, then backup existing version to puiscreens_bak.json and install this official version.
  // 4. Otherwise it's not an official version but should work OK. So leave existing puiscreens.json, and check if we already have a puiscreens_orig.json, and 
  //    create it if not.
  var targetPuiScreensFile = deployDir + dirSep + "modules" + dirSep + "puiscreens.json";
  if (fileExists(targetPuiScreensFile)) {

    var data = fs.readFileSync(targetPuiScreensFile);
    var checksum = crypto.createHash('sha512').update(data).digest('hex');  // sha512 best for 64-bit
    
    switch (checksum) {
      case "4fb38daa851aacd21cf3aeaa92304df4e0353cae2b6dab3a5fd53c0cf4d42875b5efadbb4bb29642cbff07bfdd8e1c7a9c107f582905f7fc798c3841e888ee61":
        copyFileOldVersionIs("4.6.1", "<=");
        break;
      case "2e63c0e9816f52b515c45479ada102af806bc73b79d14109567500c529bfaa166fb981ddb6062a1ba0a7f8e36a11d674a955d2f003806f21165cb26ad0fbdf33":
        copyFileOldVersionIs("4.7.0");
        break;
      
      case "b5eadc2df96e97de184cc331f133933c5f2945ab6c84997cfb30f2e6b478dfa6c8753bdb328b8257382f16a6d8e85b469af09f6d0eb872642300225590031c83":
        copyFileOldVersionIs("4.8.0");
        break;

      case "05e7b8a2a69dd12f5dafecdd032be8e42bfe07d02dc0bce2c90d8586135130dcfa134e8851dd1df00fe52021ef4d81dab09be419711837b4a4cddf536019ccfe":
      case "b5e4d420d49d48c1dd08d0f50b88018fb64ee77248edcd9a656aee9f8ba723d0a91b18751f34cfc2efcd905f71834d5c2ac5cbff552fd85d164b710c3c2e079d":
        copyFileOldVersionIs("4.9.1");
        break;
        
      case "1d469f6d2e4549dc259155a4b00d8f278ea89dc3566e18860ed9f6ccd406db8a47b0b3cbc359b397c59feac6faeb6a7fdc6ce2edbd3f120e295464dd41dd28f8":
        copyFileOldVersionIs("4.11.1");
        break;

      case "313d7e363fc9f2df66f2803116487bc75d14e647be6da33fb7be8ac886a96a58c970eecc5b147fd1a07af3c559a0de61a32893875ec0be26e6840e1945a441c3":
        copyFileOldVersionIs("4.12.0");
        break;

      case "ea10b5e751b736f4164d23e45399e6364dd95e074b36c4c996a5824fc5ba1a0436be6811c0f421510eecc57b6125e388150e5f0664dbaea681cd42e73855eb34":
        copyFileOldVersionIs("4.13.0");
        break;

      case "9768e7f3df273d809845b93390a832ed6e5b77ccbd1b51bc7ad681c8261dba0b75bf9c3f802e9784ce01a1812e45bbbf95dc8a99bd6d3b3ea43f6e5a4c1a878e":
      case "4353f5ae5067b91821825ec20190e0adf96bc87493141fba3cf1da7cea8863af2e4358cd24019223a2704eee4170c75cb4037843ca7c1f289416555ee146a851":
        copyFileOldVersionIs("5.0.0");
        break;

      case "2becc968e9db1acc1ffd6e3885d95c153d678468e69a4fdef0df725c06897b7f6ddcff82d703cb76724774729b18b56307445e728521311dbf256b97e17538d8":
        console.log("Found Standard puiscreens.json file version >= 5.2.0, no need for update.");
        break;
          
      default:
        var puiScreens = JSON.parse(data);
        console.log("Found Customized puiscreens.json file, analyzing contents...");

        // We need to check the signon screen and make sure we have lower case bound fields
        var goodUser = false, goodPassword = false, goodSubmit = false, goodError = false;

        formats:
        for (i in puiScreens.formats) {
          var format = puiScreens.formats[i];

          if (format.screen["record format name"].toLowerCase() === "signonscrn") {
            for (j in format.items) {
              var itemValue = format.items[j].value;
              if (itemValue && typeof itemValue === "object") {
                if (itemValue.fieldName === "ssuser") goodUser = true;
                else if (itemValue.fieldName === "sspassword") goodPassword = true;
              }
              var itemResponse = format.items[j].response;
              if (itemResponse && typeof itemResponse === "object") {
                if (itemResponse.fieldName === "sssubmit") goodSubmit = true;
              }
              var itemHtml = format.items[j].html;
              if (itemHtml && typeof itemHtml === "object") {
                if (itemHtml.fieldName === "sserror") goodError = true;
              }

              if (goodUser && goodPassword && goodSubmit && goodError) break formats;
            }
            break;
          }
        }

        if (goodUser && goodPassword && goodSubmit && goodError) {
          console.log("The Customized puiscreens.json file is compatible, so leaving it in place. Creating puiscreens_orig.json");
          copyFile(setupDir + dirSep + "modules" + dirSep + "puiscreens.json", deployDir + dirSep + "modules" + dirSep + "puiscreens_orig.json", "utf8");
          console.log("puiscreens_orig.json created. For latest functionality, please migrate standard fields into your customized version.");
        }
        else {
          console.log("The Customized puiscreens.json file is NOT compatible, backing it up to puiscreens_bak.json...");
          copyFile(deployDir + dirSep + "modules" + dirSep + "puiscreens.json", deployDir + dirSep + "modules" + dirSep + "puiscreens_bak.json", "utf8");
          console.log("puiscreens_bak.json created. Creating puiscreens.json ...");
          copyFile(setupDir + dirSep + "modules" + dirSep + "puiscreens.json", targetPuiScreensFile, "utf8");
          console.log("puiscreens.json created. Please migrate standard fields into your customized version.");
        }
    }
  }
  else {
    console.log("Creating puiscreens.json.");
    copyFile(setupDir + dirSep + "modules" + dirSep + "puiscreens.json", targetPuiScreensFile, "utf8");
  }
}

function createPUIUPLEXIT() {
  if (fileExists(deployDir + dirSep + "modules" + dirSep + "puiuplexit.js")) {
    console.log("puiuplexit.js file exists.");
  } 
  else {
    console.log("Creating puiuplexit.js.");
    copyFile(setupDir + dirSep + "modules" + dirSep + "puiuplexit.js", deployDir + dirSep + "modules", "utf8");
  }
}

function createPUIDNLEXIT() {
  if (fileExists(deployDir + dirSep + "modules" + dirSep + "puidnlexit.js")) {
    console.log("puidnlexit.js file exists.");
  } 
  else {
    console.log("Creating puidnlexit.js.");
    copyFile(setupDir + dirSep + "modules" + dirSep + "puidnlexit.js", deployDir + dirSep + "modules", "utf8");
  }
}

function copyPjssamples() {
  if (directoryExists(deployDir + dirSep + "modules" + dirSep + "pjssamples"))
    fse.removeSync(deployDir + dirSep + "modules" + dirSep + "pjssamples");
  console.log("Copying pjssamples.");
  copyDir(setupDir + dirSep + "modules" + dirSep + "pjssamples",  deployDir + dirSep + "modules");    
}

function validateName(name) {

  name = name.trim().toUpperCase();
  var firstChar = name.substr(0, 1);  

  if ((firstChar < "A" || firstChar > "Z") && firstChar != "#" && firstChar != "@" && firstChar != "$") {
    console.log("Name must start with an alpha character.");
    return false;
  }
  for (var i = 1; i < name.length; i++) {
    var chr = name.substr(i, 1);
    if ((chr < "A" || chr > "Z") && (chr < "0" || chr > "9") && chr != "#" && chr != "@" && chr != "$" && chr != "_" && chr != ".") {
      console.log("Name contains invalid characters.");
      return false;
    }        
  }

  if (name.length > 10) {
    console.log("Name must be 10 characters or less.");
    return false;
  }

  return true;
}

function validateIASP(name) {

  if (name.trim().toUpperCase() == "*SYSBAS")
    return true;
  else return validateName(name);

}

function isURL(path) {
  if (typeof path !== "string") return false;
  path = path.toLowerCase();
  if (path.substr(0, 7) === "http://") return true;
  if (path.substr(0, 8) === "https://") return true;
  return false;
}

function validateDirectory(directory) {
  if (IBMi) {
    var ch = directory.substr(0, 1);
    if (ch !== "/" && ch !== "\\" && !isURL(directory)) {
      directory = deployDir + dirSep + directory;
    }
    if (!directoryExists(directory) && !isURL(directory)) {
      console.log("WARNING: The specified directory was not found. You can create it later or modify the staticFilesDirectory property in config.js.");
      console.log("");
    }
  }
  return true;  // accept any entry - if directory doesn't exist, simply warn
}

function validatePort(port) {
  if (port === "0") return true;
  port = Number(port);
  if (!isNaN(port) && port >= 1 && port <= 65535) return true;
  console.log("Invalid port number. Valid range is 0-65535.");
  return false;
}


function isValidNodePath(nodePath) {

  if (!fileExists(nodePath)) {
    console.log("Path " + nodePath + " does not exist. A valid path name must be entered.");
    return false;
  }
  return true;
}


function isValidCcsid(ccsid) {

  ccsid = Number(ccsid);
  if (isNaN(ccsid)) {
    console.log("Invalid CCSID. A numeric value is required.");
    return false;
  }

  // Here's the list of valid CCSID's that can be used for jobs on IBM i
  if ([37, 256, 273, 277, 278, 280, 284, 285, 290, 297, 420, 423, 424, 425, 500, 833, 836, 838, 870, 871, 875, 880,
        905, 918, 924, 930, 933, 935, 937, 939, 1025, 1026, 1027, 1047, 1097, 1112, 1122, 1123, 1130, 1132, 1137,
        1140, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 1148, 1149, 1153, 1154, 1155, 1156, 1157, 1158, 1160, 1164,
        1166, 1175, 1364, 1371, 1377, 1388, 1399, 4971, 5026, 5035, 5123, 5233, 8612, 9030, 12708, 13121, 13124,
        28709, 57777, 61175, 62211, 62224, 62235, 62245, 62251].indexOf(ccsid) > -1)
    return true;

  console.log("Value " + ccsid + " is not a valid CCSID for the SBMJOB command.");

  return false;
}

function validateYesNo(answer) {
  answer = answer.toUpperCase();
  if (answer === "Y" || answer === "YES" || answer === "N" || answer === "NO") return true;
  console.log("Invalid answer. Use y or n.");
  return false;
}

function getConnectorLibrary() {

  var ret = {};
  if (fileExists(deployDir + dirSep + "config.js")) {

    const config = require(deployDir + dirSep + "config.js");

    if (config.connectorLibrary) {
      ret.name = config.connectorLibrary;
      if (config.connectorIASP)
        ret.IASP = config.connectorIASP;
    }
  }

  return ret;
}

function createConfig(profounduiLibrary, connectorLibrary, connectorIASP, callback) {

  if (fileExists(deployDir + dirSep + "config.js")) {

    // If the config already exists, check if any settings need to be updated

    if (!IBMi) {
      console.log("config.js file exists.");
      callback();
      return;
    }

    const config = require(deployDir + dirSep + "config.js");
    var isConfigChanged = false;
    
    // Check if it contains a profounduiLibrary setting
    if (profounduiLibrary) {

      var configProfounduiLibrary = getProfounduiLibrary();

      if (configProfounduiLibrary) {
      
        if (configProfounduiLibrary !== profounduiLibrary) {
          isConfigChanged = true;
          console.log("Updating profounduiLibrary setting in config.js from " + configProfounduiLibrary + " to " + profounduiLibrary + "...");
          config.profounduiLibrary = profounduiLibrary;
        }

      }
      else {
        isConfigChanged = true;
        console.log("config.js file exists, but does not have a profounduiLibrary setting, creating one now...");
        config.profounduiLibrary = profounduiLibrary;
      }
    }


    // Check if it contains a connectorLibrary setting
    if (connectorLibrary && connectorLibrary !== "*NONE") {

      var configConnectorLibrary = getConnectorLibrary();

      if (configConnectorLibrary.name) {
      
        if (configConnectorLibrary.name !== connectorLibrary) {
          isConfigChanged = true;
          console.log("Updating connectorLibrary setting in config.js from " + configConnectorLibrary.name + " to " + connectorLibrary + "...");
          config.connectorLibrary = connectorLibrary;
        }

      }
      else {
        isConfigChanged = true;
        console.log("config.js file exists, but does not have a connectorLibrary setting, creating one now...");
        config.connectorLibrary = connectorLibrary;
      }

      // Check if it contains a connectorIASP setting
      if (connectorIASP) {

        if (configConnectorLibrary.IASP) {

          if (configConnectorLibrary.IASP !== connectorIASP) {
            isConfigChanged = true;
            console.log("Updating connectorIASP setting in config.js from " + configConnectorLibrary.IASP + " to " + connectorIASP + "...");
            if (connectorIASP == "*SYSBAS")
              delete config.connectorIASP;
            else
              config.connectorIASP = connectorIASP;
          }

        }
        else if (connectorIASP != "*SYSBAS") {
          isConfigChanged = true;
          console.log("config.js file exists, but does not have a connectorIASP setting, creating one now...");
          config.connectorIASP = connectorIASP;
        }
      }

    }



    // Update config.js if we made any chanegs
    if (isConfigChanged) {

      fs.writeFile(deployDir + dirSep + "config.js", stringifyConfig(config), (err) => {
        if (err) 
          console.log('An error occurred updating config.js file : ' + err);
        else
          console.log('config.js file has been updated.');
        callback();
      });
    }
    else
      callback();
  }
  else {    
    
    var defaultStaticDir = "htdocs";
    if (IBMi) {
      defaultStaticDir = "/www/profoundui/htdocs";
      if (!directoryExists(defaultStaticDir)) {
        console.log("WARNING: Profound UI Installation not found in default location.");
      }
    }
    else {
      console.log("");
      console.log("You can provide the Profound UI directory as a remote URL (e.g. http://myibmi:8080) or as a local directory name. If the directory does not exist, the installer can create it for you.");
      console.log("");
    }
    
    ask("Specify Profound UI static files directory", defaultStaticDir, validateDirectory, function(staticDir) {
      ask("Specify port number for Profound.js server", portNumber, validatePort, function(newPortNumber) {
        copyFile(setupDir + dirSep + "config.js", deployDir, "utf8", function(content) {
          var config = content.substr(content.indexOf("{"));
          eval("config = " + config);
          config.staticFilesDirectory = staticDir;
          config.port = Number(newPortNumber);
          if (connectorLibrary && connectorLibrary !== "*NONE") {
            config.connectorLibrary = connectorLibrary;
            if (connectorIASP != "*SYSBAS")
              config.connectorIASP = connectorIASP;
          }
          if (profounduiLibrary)
            config.profounduiLibrary = profounduiLibrary;

          if (IBMi)
            config.showIBMiParmDefn = true;

          // Check if this is a workspace (if so, default to mysql)
          if (!IBMi && fileExists(deployDir + dirSep + "modules"  + dirSep + "app" + dirSep + ".noderun" + dirSep + "settings.json")) {
            if (config.databaseConnections) delete config.databaseConnections;  // remove property so that it's appended at the end when we set it
            config.databaseConnections = [{
              name: "default",
              default: true,
              driver: "mysql",
              driverOptions: {
                user: "user-name",
                password: "your-password",
                host: "localhost",
                database: "database-name"
              }
            }];
          }

          portNumber = newPortNumber;
          content = "\nmodule.exports = ";
          content += JSON.stringify(config, null, "  ");
          content += "\n";
          return content;
        });
        console.log("");
        console.log("config.js created.");
        console.log("");
        
        if (!IBMi && !isURL(staticDir)) {
          var absoluteStaticDir = path.resolve(deployDir, staticDir);
          if (!directoryExists(absoluteStaticDir)) {
            console.log("");
            console.log("The specified directory for Profound UI was not found.");
            ask("Should the installer create the directory and download a copy of Profound UI static files?", "y", validateYesNo, function(answer) {
              if (answer.toUpperCase() == "Y") {
                downloadHtdocs(absoluteStaticDir, callback);
              }
              else {
                callback();
              }
            });
          }
          else {        
            callback();
          }
        }
        else {
          callback();
        }
      });
    });
  }
}

function finish() {
  process.stdin.destroy();
  console.log("");
  process.exit(0);
}

function runCommand(command, switches) {
  console.log("");
  console.log("Executing command: " + command);
  const child_process = require("child_process");
  var args = [command];
  if (typeof switches == "string")
    args.unshift(switches);
  else 
    args.unshift("-e");
  
  // Many IBM commands cannot run in multi-threaded mode...
  var options = {stdio: "inherit", cwd: setupDir, env: {QIBM_USE_DESCRIPTOR_STDIO:"Y", QIBM_MULTI_THREADED:"N"}};
  
  var results = child_process.spawnSync(
    "system",
    args,
    options);
    
  var code = results.status;
  var signal = results.signal;

  if (code != null) {    
    if (code === 0) {
      console.log("Command finished successfully.");
      return true;
    }
    else {
      console.log("Process exited, code %d", code);
    }
  }
  else {
    console.log("Process ended due to signal %s", signal);
    console.log(results);  // show full results including detailed error
  }
  return false;
}


function getProfounduiLibrary() {

  if (fileExists(deployDir + dirSep + "config.js")) {

    const config = require(deployDir + dirSep + "config.js");

    if (config.profounduiLibrary) {
      return config.profounduiLibrary;
    }
  }

  return null;
}


function askPuiLibrary(callback) {

  var defaultProfounduiLibrary = getProfounduiLibrary();

  ask("Specify Profound UI installation library", (defaultProfounduiLibrary) ? defaultProfounduiLibrary : "PROFOUNDUI", validateName, function(puiLibrary) {
    callback(puiLibrary.trim().toUpperCase());
  });

}


function askConnector(callback) {

  ask("Install Profound.js Connector IBM i ILE components?", "y", validateYesNo, function(answer) {
  
    if (answer.toUpperCase() == "Y") {
      
      var connectorLibrary = getConnectorLibrary();
      ask("Enter Profound.js Connector library name:", (connectorLibrary.name) ? connectorLibrary.name : "PROFOUNDJS", validateName, function(answer) {
      
        var name = answer.trim().toUpperCase();
        ask("Enter Profound.js Connector library IASP:", (connectorLibrary.IASP) ? connectorLibrary.IASP : "*SYSBAS", validateIASP, function(answer) {

          callback(name, answer.trim().toUpperCase());

        });

      });
      
    }
    else {
      
      callback("*NONE");
      
    }
  
  });
}


function getServerInstances(instanceRootDir) {

  const serverInstances = [];
  if (directoryExists(pjsBaseInstance)) {
    
    const instanceDirs = fs.readdirSync(pjsBaseInstance);
    instanceDirs.forEach((instanceDir) => {
      
      let data
      try {
        
        data = fs.readFileSync(path.join(pjsBaseInstance, instanceDir, "/conf"), "utf8");
      
      }
      catch (error) {
        
        return;
        
      }
      let options = data.split('\n');
      let config = { name: instanceDir, autostart: "n", ccsid: 37, nodePath: "/QOpenSys/pkgs/bin/node" };

      options.forEach(option => {

        let parts = option.split('=');
        let configOption = parts[0].trim();

        switch (configOption) {
          case 'path':
            config.path = parts[1].trim();
            break;
          case 'nodePath':
            config.nodePath = parts[1].trim();
            break;
          case 'nodeArgs':
            config.nodeArgs = parts[1].trim();
            break;
          case 'autostart':
            config.autostart = (parts[1].trim() === '1') ? 'y' : 'n';
            break;
          case 'ccsid':
            config.ccsid = parts[1].trim();
            break;
          case '':
            break;
          default:
            break;
        }
      });
      if (config.path === instanceRootDir + dirSep + 'start.js')
        serverInstances.push(config);
      
    });
  
  }
  if (serverInstances.length === 0)
    serverInstances.push({ name: "PROFOUNDJS", autostart: "y", ccsid: 37, nodePath: "/QOpenSys/pkgs/bin/node" });
  return serverInstances;

}


function askServerInstance(callback) {

  serverInstances = getServerInstances(deployDir);

  if (serverInstances.length > 1) {
    console.log('\nWARNING - Multiple STRTCPSVR/ENDTCPSVR instances found for this server in ' + pjsBaseInstance + ' : -\n');
    serverInstances.forEach(serverInstance => {
      console.log(JSON.stringify(serverInstance));
    });
  }

  ask("\nCreate/replace server instance configuration for STRTCPSVR/ENDTCPSVR commands?", "y", validateYesNo, function(answer) {

    if (answer.toUpperCase() == "Y") {

      ask("Server instance name:", serverInstances[0].name.toUpperCase(), validateName, function(answer) {

        var svrname = answer.trim().toUpperCase();

        ask("Specify CCSID for instance " + svrname, serverInstances[0].ccsid, isValidCcsid, function(ccsid) {

          ask("Specify Node.js path for instance " + svrname, serverInstances[0].nodePath, isValidNodePath, function(nodePath) {

            ask("Autostart server instance " + svrname + " when TCP/IP starts?", serverInstances[0].autostart, validateYesNo, function(answer) {

              var autostart = (answer.toUpperCase() == "Y");
              callback(svrname, autostart, ccsid, nodePath);

            });
          });
        });
      });

    }
    else {

      callback("*NONE");

    }

  });
}


function stringifyConfig(config) {

  // JavaScript functions (like connectorIPFilter) will be lost when doing JSON.stringify,
  // so we need to do some magic to preserve them.
  
  let funkz = [];
  let configString = "\nmodule.exports = ";

  configString += JSON.stringify(config, (key, val) => {
      if (typeof val === 'function') {
        let n = funkz.length;
        funkz.push(val.toString());
        return `___function${n}___`;
      }
      return val;
  }, "  ");
  
  configString += "\n";

  for (var i=0; i<funkz.length; i++) {
    configString = configString.replace(`"___function${i}___"`, funkz[i]);
  }

  return configString;

}


if (["win32", "darwin", "linux"].includes(os.platform()))
  installNodeGit();
createPackageFile();
createModulesDirectory();
createPuiscreens();
createPUIUPLEXIT();
createPUIDNLEXIT();
copyPjssamples();

createStoreCredentials(function() {
  createUpdatepui(function() {
    createCall(function() {
      createStart(function() {
        if (IBMi && !silent) {
          console.log("");
          askPuiLibrary(function(profounduiLibrary) {
            askConnector(function(connectorLibrary, connectorIASP) {
              createConfig(profounduiLibrary, connectorLibrary, connectorIASP, function() {
                askServerInstance(function(svrname, autostart, ccsid, nodePath) {
                  if (connectorLibrary != "*NONE" || svrname != "*NONE") {
                    // First, try copying the save file
                    var success = runCommand("CPYFRMSTMF FROMSTMF('" + setupDir + dirSep + "pjsdist.savf') TOMBR('/QSYS.LIB/QGPL.LIB/PJSDIST.FILE') MBROPT(*REPLACE)");
                    if (success) {
                      // Now, try restoring the PJSINSTALL program
                      success = runCommand("RSTOBJ OBJ(PJSINSTALL) SAVLIB(QTEMP) DEV(*SAVF) OBJTYPE(*ALL) SAVF(QGPL/PJSDIST) RSTLIB(QGPL)");
                      if (success) {
                        // Now, try running PJSINSTALL
                        var command = "QGPL/PJSINSTALL CONNLIB(" + connectorLibrary + ")";
                        if (connectorLibrary != "*NONE")
                          command += " CONNIASP(" + connectorIASP + ") CONNHOST('localhost') CONNPORT(" + portNumber + ")";
                        command += " SVRNAME(" + svrname + ")";
                        if (svrname != "*NONE")
                          command += " SVRDIR('" + deployDir + "') " +
                            "SVRAUTO(" + ((autostart) ? "*YES" : "*NO") + ") CCSID(" + ccsid + ") NODEPATH('" + nodePath + "')";
                        success = runCommand(command, "-Ke");
                        // Clean up program and save file
                        console.log("");
                        console.log("Cleaning up...");
                        runCommand("DLTPGM PGM(QGPL/PJSINSTALL)");
                        runCommand("DLTCMD CMD(QGPL/PJSINSTALL)");
                        runCommand("DLTPNLGRP PNLGRP(QGPL/PJSINSTALL)");
                        runCommand("DLTMSGF MSGF(QGPL/PJSINSTALL)");
                        runCommand("DLTF FILE(QGPL/PJSDIST)");
                        console.log("");
                        if (success) {
                          console.log("Profound.js successfully installed.");
                        }
                        else {
                          console.log("Profound.js did NOT install successfully! Check messages above.");
                        }
                      }
                      else {
                        // Clean up save file
                        console.log("");
                        console.log("Cleaning up...");
                        runCommand("DLTF FILE(QGPL/PJSDIST)");
                        console.log("");
                        console.log("Profound.js did NOT install successfully! Check messages above.");
                      }
                    }
                    else {
                      console.log("");
                      console.log("Profound.js did NOT install successfully! Check messages above.");
                    }
                    finish();
                  }
                  else {
                    finish();
                  }
                });
              });
            });
          });
        }
        else {
          createConfig(null, null, null, function() {
            console.log("");
            console.log("Installation completed.");
            finish();
          });
        }
      });
    });
  });
});

function installNodeGit() {

  child_process.execSync(
    "npm install nodegit",
    {
      cwd: path.resolve(__dirname, ".."),
      stdio: ["ignore", "inherit", "inherit"]
    }
  );

}
